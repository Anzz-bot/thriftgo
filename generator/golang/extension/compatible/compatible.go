// Copyright 2021 CloudWeGo Authors
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//   http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// Package compatible provides functions that help generated code using the
// apache/thrift go library with version v0.13.0 to upgrade to v0.14.0 in
// spite of the breaking changes between these two versions.
//
// There are 3 major incompatibility API changes in the v0.14.* version of
// the apache/thrift go library:
//     - TProtocol's methods introduced context.Context as the first parameter.
//     - TClient's Call method added an extra return value, the ResponseMeta.
//     - TException added a method to return its exception type.
// These changes cause the codes generated by thriftgo incompatible with
// the higher versions of apache/thrift. The end users of generated code
// have no other choice but to keep the dependency version of apache/thrift
// in v0.13.0.
//
// To prevent users from facing the annoying compile errors caused by the
// mismatched generated code and version of apache/thrift, we added an
// 'compatible' mode to make generated code compatible with both the versions
// v0.13.0 and v0.14.0 of the apache/thrift go library by wrapping some key
// point in the codes.
package compatible

import (
	"bytes"
)

var (
	// boundary of functions
	beg = []byte("func ")
	end = []byte("}")

	// thrift.TProtocol
	prot  = []byte("prot thrift.TProtocol")
	iprot = []byte("iprot.") // replaced as 'xprot.'
	oprot = []byte("oprot.") // replaced as 'yprot.'
	xprot = []byte("\txprot := compatible.ProtocolDropContext(iprot)")
	yprot = []byte("\typrot := compatible.ProtocolDropContext(oprot)")

	// thrift.TClient.Call
	call1 = []byte("p.Client_().Call(ctx")
	call2 = []byte("compatible.Call(ctx, p.Client_()")

	// thrift.TApplicationException.Write
	write = []byte("x.Write(oprot)")
	wrote = []byte("compatible.StructDropContext(x)")

	// thrift.TException
	except1 = []byte("thrift.WrapTException")
	except2 = []byte("compatible.WrapException")
)

// Patch searches through the given source code -- which must be formated
// already -- to find the invocations of TClient's Call or TProtocol's methods
// and replaces them with a wrapped version to hide the incompatibility of
// those methods when the apache/thrift go library changes.
// Patch is designed for code that are generated to use apache/thrift go library
// with version v0.13.0. The result compiles well with v0.13.0 and v0.14.0 of
// the apache/thrift go library.
func Patch(content []byte) ([]byte, error) {
	cnt := bytes.Count(content, prot)
	if cnt == 0 {
		return content, nil
	}

	var inside, xi, yo bool
	var buffer, stash [][]byte
	lines := bytes.Split(content, []byte("\n"))
	buffer = make([][]byte, 0, len(lines)+cnt)
	for _, ln := range lines {
		// wrap TClient's Calls
		if nl := bytes.Replace(ln, call1, call2, 1); len(nl) != len(ln) {
			buffer = append(buffer, nl)
			continue
		}

		if !inside {
			if bytes.HasPrefix(ln, beg) && bytes.Contains(ln, prot) {
				inside = true
			}
			buffer = append(buffer, ln)
		} else {
			// Inside a function, we scan and modify the uses of iprot and oprot.
			// When reaching the close of the function, we should add necessary
			// type wrappings at the beginning of the function.
			if bytes.HasPrefix(ln, end) {
				inside = false
				if xi {
					buffer = append(buffer, xprot)
				}
				if yo {
					buffer = append(buffer, yprot)
				}
				buffer = append(buffer, stash...)
				buffer = append(buffer, ln)
				stash, xi, yo = stash[:0], false, false
			} else {
				// wrap local TApplicationExceptions
				if idx := bytes.Index(ln, write); idx >= 0 && idx+len(write) == len(ln) {
					tmp := append(ln[:idx], wrote...)
					tmp = append(tmp, write[1:]...)
					stash = append(stash, tmp)
					continue
				}

				// wrap the return errors
				if nl := bytes.Replace(ln, except1, except2, 1); len(nl) != len(ln) {
					stash = append(stash, nl)
					continue
				}

				// replace 'iprot' with 'xprot' and 'oprot' with 'yprot'
				stash = append(stash, ln)
				if idx := bytes.Index(ln, iprot); idx >= 0 {
					ln[idx] = 'x'
					xi = true
				}
				if idx := bytes.Index(ln, oprot); idx >= 0 {
					ln[idx] = 'y'
					yo = true
				}
			}
		}
	}
	content = bytes.Join(buffer, []byte("\n"))
	return content, nil
}
